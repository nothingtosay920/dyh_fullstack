# 垃圾回收

手动回收 c/c++
自动回收 js java py

# 栈中的垃圾数据 和 堆中的垃圾数据是怎么回收的
栈中的垃圾数据：
  js：引擎会通过向下移动ESP指针来销毁函数保存在栈中的执行上下文

堆中的垃圾数据：

# 代际假说 和 分代收集

  代际假说 (策略):
  1. 大部分对象在内存中存在的时间很短 简单来说 很多对象一经分配内存 很快就变得不可访问 
  2. 不死的对象会活的更久

V8 会把堆分成 新生代 和 老生带 两个区
  新生代：存放生存时间短的对象 1~8M的容量 被副垃圾回收器回收
  老生代：存放生存时间长的对象 很大 被主垃圾回收器回收

# 垃圾回收器的工作流程
无论什么类型的垃圾回收器 都有一套共同的执行流程
1. 标记空间中的活动对象(还在使用的对象)和非活动对象(可以进行垃圾回收的对象)
2. 回收非活动对象所占据的内存
3. 做内存整理 频繁回收对象后 就会出现大量不连续的空间 (内存碎片)

# 副垃圾回收器
主要负责新生区的垃圾回收 通常情况下 大多数小的对象都会被分配到新生区 但是回收很频繁

scavenge算法 会把新生区的内存一分为二 分成对象区域和空闲区域 然后标记对象区域里面所有的对象 把活对象复制空闲区域 此过程还会做好排序 相当于做了内存整理。然后清空对象区域，再角色翻转

当存活对象过多 新生区空间不够时 js会采用对象晋升策略 (经过两次垃圾回收还存活的对象 直接移到老生区)


# 主垃圾回收器
主要负责老生区的垃圾回收 老生区中的对象来自新生区中晋升的对象 和 一些本身就很大的对象

标记-清除的算法 首先是标记阶段 (递归遍历的区域记一组对象 但凡是能找到一个节点的对象 那这组对象就是活对象 一个活对象都没有的成为垃圾数据)
Mark-Compact添加了活动对象整理阶段，将所有的活动对象往一端移动，移动完成后，直接清理掉边界外的内存。

# 全停顿
因为js是运行在v8的主线程上的 而垃圾回收的算法也在主线程 那么久会出现当需要垃圾回收时 js的运行会暂停 等到垃圾回收完毕后再恢复运行 ---全停顿

全停顿在新生区是没有太大的影响 v8将标记过程分成一个个子标记过程 同时让垃圾回收标记和js应用逻辑交替进行 直到标记完成(增量标记算法)